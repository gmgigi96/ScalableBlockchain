\chapter{Stato dell'arte}

\section{Algorand}

Algorand~\cite{gilad2017algorand, chen2019algorand} è una nuova criptovaluta, progettata da Silvio Micali, professore del MIT e vincitore del premio Turing nel 2012, che possiede le tre proprietà di decentralizzazione, sicurezza e scalabilità descritte nel blockchain trilemma: è infatti in grado di confermare le nuove transazioni nell'ordine di un minuto scalando su numerosi utenti. Algorand, a differenza di Bitcoin e tecnologie che ereditando le sue caratteristiche, non usa Proof-of-Work. In Bitcoin ogni blocco viene aggiunto alla blockchain ogni 10 minuti, tramite una gara crittografica molto costosa in termini di potenza computazionale, e di conseguenza di costo di elettricità, il che si traduce in uno spreco di risorse per quasi tutti i nodi della rete che non hanno trovato la soluzione al puzzle crittografico. Questa soluzione chiaramente non scala: un blocco ogni 10 minuti a livello globale non è sufficiente per gestire il gran numero di transazioni che verrebbero generate.
Proof-of-Work, l'algoritmo progettato per essere decentralizzato, a causa della sua natura dispendiosa, si sta trasformando un un meccanismo centralizzato: i miner oggi sono dei professionisti, che investono una grande quantità di denaro in hardware specializzato, e si riuniscono in pool di grandi dimensioni, in modo tale da dividere il lavoro e l'eventuale ricompensa ottenuta. Perciò qualsiasi utente con il suo pc domestico, entrando nella rete Bitcoin (o simili), spreca solamente una grande quantità di energia elettrica senza alcun ritorno economico. Si stima infatti, che l'81\% del hash power sia detenuto dalle mining pool della Cina\todo{Inserire citazione: https://www.buybitcoinworldwide.com/mining/pools/}: se queste si unissero potrebbero modificare completamente il contenuto della blockchain e prendere qualsiasi decisione nella conferma di transazioni, proprio come un sistema centralizzato.
Infine, un altro svantaggio di Proof-of-Work è l'esistenza inevitabile di fork. Infatti, poiché due o più miner possono risolvere nello stesso momento il puzzle crittografico, il prossimo blocco candidato non unico. I miner cominceranno a minare il blocco successivo sulla base di uno dei due precedenti blocchi, in base a ciò che vedono per primo a causa della latenza su rete. Questo porta alla creazione di catene alternative, che prima o poi verrano risolte, causando una dissoluzione dei blocchi delle catene eliminate e di conseguenza un annullamento delle transazioni, generando continuamente incertezza. Bitcoin, infatti, considera confermata una transazione quando si trova ad almeno a profondità 6. \'E chiaro che il tempo di conferma di una transazione non è più di soli 10 minuti, ma di un'ora. Quindi Proof-of-Work può essere riassunto in tre parole: dispendioso, incerto ed incredibilmente lento.

Algorand utilizza un protocollo per il problema dei generali bizantini denominato \emph{BA$\star$}, in grado di scalare a molti utenti, raggiungendo il consenso su un blocco con una bassa latenza e senza fork, evitando attacchi Sybil, che influenza qualsiasi altro protocollo di consenso bizantino, come ???\todo{citazioni a pbft e altri...}, e resiliente ad attacchi di tipo denial-of-service, continuando ad operare anche se alcuni utenti sono stati disconnessi da un attaccante.

Algorand affronta questi obiettivi usando numerose tecniche:
\begin{itemize}
	\item \textbf{Utenti pesati}: ad ogni utente è assegnato un peso in base ai soldi che possiede, per prevenire attacchi Sybil, ispirandosi agli approcci Proof-of-Stake\todo{inserire citazioni proof of stake}, un'alternativa all'approccio Proof-of-Work. La differenza fondamentale tra le criptovalute basate su Proof-of-Stake ed Algorand è che, mentre nel primo chi tenta di creare un fork viene punito perdendo dei soldi che aveva bloccato precedentemente su un fondo, nel secondo i pesi sono solo utilizzare per prevenire attacchi Sybil. \emph{BA$\star$} garantisce un funzionamento corretto se il totale dei soldi posseduti dagli utenti onesti è maggiore dei $2/3$ dei soldi totali.
	\item \textbf{Comitati}: il consenso è ottenuto in maniera scalabile da \emph{BA$\star$} tramite dei comitati, un sottoinsieme degli utenti selezionato ad ogni round in modo randomico ed in base al proprio peso.
	\item \textbf{Lotteria crittografica}: per prevenire tentativi di corruzione o attacchi DoS ai membri di un comitato, questi vengono selezionati in modo privato e senza alcun scambio di messaggio tra i partecipanti alla rete. Ogni utente è in grado di sapere se fa parte di un comitato, utilizzando una funzione, la Verifiable Random Function (VRF)~\cite{micali1999verifiable}. In questo modo un attaccante non può conoscere chi farà parte del prossimo comitato.
	\item \textbf{Rotazione dei membri}: Un attaccante può attaccare un membro di un comitato quando questo comunica con gli altri membri. Tuttavia \emph{BA$\star$} non ha bisogno di alcun stato per funzionare, se non della chiave privata degli utenti, per cui qualsiasi altro utente può essere selezionato e partecipare in ogni passo del protocollo.
\end{itemize}

In Algorand ogni utente deve possedere una chiave privata e la corrispettiva chiave pubblica. La blockchain mantiene le transazioni confermate racchiuse in blocchi semplicemente connessi, con un riferimento all'hash del blocco precedente. Le transazioni sono dei trasferimenti di denaro, espressi in unità di Algorand, da un utente all'altro, ma possono contenere anche \emph{smart contract} nelle versioni più recenti \cite{smartcontract2019algo, smartcontract2020algo}. Inoltre, tutte le operazioni sono svolte dai client presenti sulla rete in modo asincrono con una suddivisione del tempo in round, al termine del quale si aggiunge un nuovo blocco alla blockchain.
La comunicazione è basata sul protocollo \emph{gossip} \cite{kermarrec2007gossiping}, un protocollo di comunicazione usato nelle reti P2P, simile al broadcast, in cui ogni utente seleziona randomicamente i peer vicini a cui inviare un messaggio. Ogni peer effettua la validazione del messaggio che ha ricevuto, verificandone la firma prima di inoltrarlo nuovamente. Ogni utente che genera una nuova transazione, la invia alla rete mediante il protocollo gossip, ed ogni peer che la riceve, la valida e se è ben formata la aggiunge alla lista delle transazioni in attesa. Mediante \emph{BA$\star$}, Algorand conferma le transazioni in attesa.

Ogni round è diviso in due fasi: (1) proposta del nuovo blocco e (2) conferma del blocco mediante \emph{BA$\star$}.
In ogni fase viene eseguita una \emph{lotteria crittografica} in cui si selezionano i peer, in modo randomico e sulla base dei loro pesi, che si occuperanno di uno specifico compito all'interno della fase stessa. Ad ogni utente $i$ è infatti assegnato un peso $w_i$ sulla base dei soldi che possiede nel proprio conto. Se $W = \sum_i w_i$ è la somma di tutti i pesi dell'utente, la probabilità che il peer $i$ è selezionato è proporzionale ad $w_i/W$. La selezione è basata sulle Verifiable Random Function (VRF)~\cite{micali1999verifiable}, una funziona che genera un \emph{hash} ed una \emph{proof}. L'\emph{hash} è un numero pseudo-randomico basato su un \emph{seed}, conosciuto da tutta la rete, e su una chiave privata $sk$, mentra la \emph{proof} permette di verificare l'hash data la chiave pubblica $pk$ associata ad $sk$.
Il sorteggio crittografico è basato sull'Algoritmo~\ref{alg:sortition}.
\begin{algorithm}
	\caption{L'algoritmo utilizzato per la lotteria crittografica in Algorand}
	\begin{algorithmic}
		\Procedure{sortition}{$sk, seed, \tau, role, w, W$}
			\State{$\langle hash, \pi \rangle \leftarrow$\Call{VRF$_{sk}$}{$seed \oplus role$}}
			\State $p \leftarrow \frac{\tau}{W}$
			\State $j \leftarrow 0$
			\While{$\frac{hash}{2^{hashlen}} \notin [ \sum_{k = 0}^j B(k; w, p), \sum_{k=0}^{j+1} B(k; w, p) )$}
			\State $j \leftarrow j + 1$
			\EndWhile
			\Return $\langle hash, \pi, j \rangle$
		\EndProcedure
	\end{algorithmic}
	\label{alg:sortition}
\end{algorithm}
La selezione di ogni utente è basata sul suo peso $w$, e per questo un utente può essere selezionato più di una volta: infatti la variabile $j$ restituita dalla funzione indica quanti \emph{sotto-utenti} l'utente rappresenta. Ogni unità di Algorand rappresenta un differente \emph{sotto-utente}. Se un utente $i$ possiede $w_i$ unità di Algorand, $i$ possiede $w_i$ \emph{sotto-utenti} ognuno avente probabilità $p = \frac{\tau}{W}$ di essere selezionato. $\tau$ rappresenta il numero atteso di utenti selezionati per un certo ruolo \emph{role}, facenti parte dello stesso comitato. Il ruolo può essere ad esempio quello di proposta del prossimo blocco, oppure di un comitato di conferma di un blocco. La probabilità che esattamente $k$ degli $w$ \emph{sotto-utenti} vengano selezionati è data dalla distribuzione binomiale, $B(k; w, p) = \binom{w}{k} p^k (1-p)^{w-k}$, dove $\sum_{k=0}^w B(k; w, p) = 1$. L'\emph{hash} determina (grazie al ciclo \emph{while}) il numero di \emph{sotto-utenti} $j$ selezionati per un utente $i$: infatti nel ciclo while si seleziona il segmento di lunghezza $B(j; w, p)$ (a cui corrispondono esattamente $j$ \emph{sotto-utenti} selezionati tra i $w$ disponibili) in cui ricade il valore $\frac{hash}{2^hashlen}$, compreso tra $0$ e $1$, in cui \emph{hashlen} è la lunghezza in bit dell'\emph{hash}. La Figura~\ref{fig:---} visualizza la selezione di $j$. \todo{inserire immagine come https://miro.medium.com/max/1400/1*qKFBhPqJQpDBGGdiP39U3Q.png in cui si inserisce una freccia rappresentate hash / 2**hashlen per far vedere la selezione di j}
Poichè $B(k_1; n_1, p) + B(k_2; n_2, p) = B(k_1+k_2; n_1 + n_2, p)$, un attacco in cui si divide una somma di denaro tra più Sybil non ha alcun effetto.
Un attaccante per avere il massimo numero $j$ di \emph{sotto-utenti} che rappresenta, deve sperare di ottenere un \emph{hash} elevato, che non può però decidere arbitrariamente poiché deve dimostrare di averlo ottenuto. L'unico modo è quello di tentare con più chiavi private $sk$, ma il protocollo prevede che $sk$ sia generata prima della generazione del \emph{seed}.
Il seed per il round $r$ viene generato da ogni utente $u$ selezionato per la proposta del blocco, come $\langle seed_r, \pi \rangle \leftarrow$ VRF$_{sk_u}(seed_{r-1} \oplus r)$, ed incluso nella proposta di blocco. In questo modo quando al termine del round $r-1$ il blocco viene accettato, tutta la rete conosce il nuovo seed. Se il seed non è valido, o si raggiunge il consenso sul blocco vuoto (ovvero non si raggiunge il consenso su un blocco nel round attuale), si seleziona come seed per il round $r$ il valore $H(seed_{r-1} \oplus r)$, dove $H$ è una funzione hash crittografica.

\paragraph*{Fase 1: proposta del blocco}
Ogni utente esegue il sorteggio crittografico in privato e senza scambio di messaggi per determinare se è stato selezionato per proporre il prossimo blocco da aggiungere alla blockchain. Poiché il sorteggio è randomico, gli utenti selezionati saranno più di uno. Ogni utente propone come blocco, quello contenente tutte le transazioni in attesa. Ad ogni blocco è assegnata una priorità in modo da limitare il costo di comunicazione per la trasmissione di blocchi, che potrebbero essere di grandi dimensioni (ad esempio 1 MB). La priorità viene calcolata nel seguente modo: per ogni \emph{sotto-utente} $1, ..., j$ di un utente $i$, la priorità del blocco è il massimo hash ottenuto applicando una funzione hash crittografica all'\emph{hash} di output della VRF per $i$ concatenato all'indice del \emph{sotto-utente}. In questo modo un utente che possiede più soldi ha più probabilità di avere una priorità maggiore degli altri. Ogni utente (che ha il ruolo di proporre il nuovo blocco per il round attuale) invia in rete, mediante il protocollo gossip, un messaggio contenente il blocco proposto, la priorità e la proof ottenuta dalla VRF, per dimostrare il proprio ruolo e la priorità ottenuta. Ogni altro utente smette di ritrasmettere il blocco se questo ha una priorità più bassa rispetto a quelli che ha ricevuto precedentemente all'interno del round. Infine, ogni utente deve attendere un certo periodo di tempo in cui riceve le proposte di blocco: è chiaro che attendere meno tempo di quello che servirebbe significherebbe o non ricevere alcun blocco, o ricevere un blocco che potrebbe non essere quello a più alta priorità. Nel primo caso la fase 2 sarebbe inizializzata con un blocco vuoto. Se invece si attenderebbe più tempo di quello che effettivamente possa servire, si avrebbe solo un degradamento delle performance. Il team di Algorand assicura che in entrambi i casi il consenso si possa raggiungere, e che questo impatti solo sulle performance. Risultati sperimentali, indicano che il tempo di attesa migliore sia di circa 5 secondi.

\paragraph*{Fase 2: consenso mediante \emph{BA$\star$}}
La seconda fase è quella in cui si raggiunge il consenso su un singolo blocco da aggiungere alla blockchain, mediante \emph{BA$\star$}. Questa fase è divisa in step: ogni step viene selezionato un nuovo comitato tramite sorteggio crittografico. Per raggiungere il consenso, infatti, non è necessario alcun stato, se non una chiave privata, per cui è possibile creare un comitato ad ogni step, per evitare attacchi da utenti malevoli, che scoprono l'identità dei membri del comitato.
Ogni membro, in ogni step, propone il blocco (inviando oltre il blocco, anche la proof di selezione nel comitato), inizializzato con quello a priorità massima, e si contano i voti ottenuti per ogni proposta, finché non si raggiunge una certa soglia, e quindi un consenso. In particolare \emph{BA$\star$} raggiunge due tipi di consenso: \emph{final}, in cui ogni altro utente che ha raggiunto un consenso \emph{final} o \emph{tentative}, lo ha raggiunto su uno stesso blocco, e \emph{tentative}, in cui tutti gli altri utenti hanno raggiunto un consenso \emph{tentative} su blocchi differenti. Quest'ultimo caso si può verificare quando ci sono partizionamenti su rete. Tutte le transazioni in un blocco \emph{final} sono confermate, mentre le transazioni in un blocco \emph{tentative} sono confermate solo se uno dei blocchi successivi è \emph{final}.
Se tutti gli utenti onesti propongono lo stesso blocco iniziale, \emph{BA$\star$} raggiunge un consenso in soli 4 step, mentre nel caso in cui un utente malevolo sia particolarmente fortunato, il consenso si raggiunge in non più di 13 step~\cite{chen2019algorand}.

\section{Bernardini}

\section{Sharding}